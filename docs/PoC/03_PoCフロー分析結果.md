# PoCフロー分析結果

## 1. はじめに

本ドキュメントは、「広島県内バス情報提供アプリ PoC版」開発における、完成までのフローを分析した結果をまとめたものです。
分析は `01_システム概要_PoC.md` および `02_ドメインモデル図_PoC.md` に基づいて行いました。

PoCの主要目的は、**「指定した一つのバス停における、直近のバス数本のリアルタイム到着予定時刻（遅延情報込み）表示」** というMVP（Minimum Viable Product）を迅速に実現し、コアバリューを検証することです。

## 2. PoC開発全体の流れ

PoC開発は、以下の大きな流れで進めます。

1.  **基盤準備とデータ処理層の構築**: MVPに必要なデータの取り込みと処理基盤を整備します。
2.  **バックエンドAPIの開発**: フロントエンドが必要とする情報を返すAPIを構築します。
3.  **フロントエンドの開発**: ユーザーが情報を閲覧できるUIを構築します。
4.  **統合テストとデプロイ**: 各コンポーネントを結合し、動作検証後、デプロイします。

## 3. 詳細な開発ステップ

### フェーズ1: 基盤準備とデータ処理 (バックエンド)

このフェーズでは、MVP実現に不可欠なバスデータの準備と、それを処理するための基盤を構築します。

1.  **GTFS静的データ (GTFS-JP) の準備と取り込み戦略策定:**
    *   **対象データ**: MVPで最低限必要なデータ（バス停名、関連する路線IDなど）を特定します。`StopAggregate` の `StopId`, `StopName` や `RouteAggregate` の `RouteId` が関連します。
    *   **格納先**: Cloudflare D1 データベース。
    *   **取り込み方法**: PoC段階では、手動更新または非常にシンプルな一括登録バッチ処理を想定します。
    *   **ドメインモデル**: `Stop`, `Route`, `FeedInfo` エンティティを参考にスキーマを検討します。

2.  **GTFSリアルタイムデータ (GTFS-RT TripUpdate) の処理バッチ開発:**
    *   **目的**: 指定したバス停に関連する運行の遅延状況や到着予測時刻を解析し、D1データベースに保存・更新します。
    *   **取得頻度**: `01_システム概要_PoC.md` に基づき、30秒に1回程度を想定。
    *   **データ処理**: GTFS-RTフィードを解析し、`TripAggregate` の `TripStatus` や `StopTimeAggregate` の `ActualTime`, `ScheduledTime`, `StopTimeStatus` などを更新します。
    *   **技術選定**: Cloudflare Workers (Scheduled Handler) を利用。
    *   **永続化**: 処理結果をD1データベースに保存。`Trip` および `StopTime` エンティティの状態を更新します。

### フェーズ2: バックエンドAPI開発 (Hono on Cloudflare Workers)

MVPで定義された「指定した一つのバス停における、直近のバス数本のリアルタイム到着予定時刻（遅延情報込み）表示」を実現するためのAPIを開発します。

1.  **APIエンドポイント設計・実装:**
    *   **エンドポイント例**: `GET /api/stops/:stopId/schedule`
    *   **リクエスト**: バス停ID (`stopId`)
    *   **レスポンス**: 指定されたバス停の直近数件のバス到着予定時刻（遅延考慮済み）、路線名、行き先など。
    *   **ドメインロジック**:
        *   `StopQuery` のようなサービスクラスを設け、D1から `stopId` に関連する `StopTime` 情報を取得。
        *   `Trip` 情報と紐付けて、遅延を考慮した到着予定時刻を計算。
        *   `Route` 情報から路線名を取得。
    *   **フレームワーク**: Hono を使用。
    *   **エラーハンドリング**: `neverthrow` を活用したResult型によるエラー処理。
    *   **バリデーション**: `zod` を用いたリクエストパラメータおよびレスポンスデータのバリデーション。

2.  **ユニットテスト (Vitest):**
    *   APIエンドポイントのロジック、ドメインサービス、値オブジェクトなどのユニットテストを作成します。
    *   `StopId`, `TripId` などの値オブジェクトのバリデーションロジックは重点的にテストします。

### フェーズ3: フロントエンド開発 (Angular)

ユーザーがバスの到着情報を確認できるシンプルなUIを開発します。

1.  **画面設計・実装 (単一画面):**
    *   **バス停選択UI**:
        *   PoC初期段階では、ハードコードされたバス停リストからの選択、または固定のバス停IDを用いるなど、ごく簡単な方法を想定。
    *   **リアルタイム到着情報表示**:
        *   選択されたバス停の情報をバックエンドAPIから取得。
        *   取得した情報をリスト形式などで分かりやすく表示（路線名、行き先、到着予定時刻、遅延情報）。
    *   **技術**: Angular を使用。

2.  **API連携:**
    *   作成したバックエンドAPI (`/api/stops/:stopId/schedule`) を呼び出し、レスポンスを表示に反映させます。
    *   Angularの `HttpClient` を利用。

3.  **基本的なUIテスト:**
    *   主要な表示項目が正しく表示されるか、簡単な操作が可能かなどを確認します。

### フェーズ4: 統合とE2Eテスト

バックエンドとフロントエンドを結合し、MVPとしての機能が全体として正しく動作することを確認します。

1.  **E2Eテスト (Playwright):**
    *   ユーザーがバス停を選択し、リアルタイム到着情報が表示されるまでの一連のフローを自動テストします。
    *   プレビュー環境に対して実行することを想定。

2.  **MVP機能の総合的な動作確認:**
    *   遅延情報が正しく反映されるか。
    *   データの更新頻度と表示の整合性。
    *   エラーケースのハンドリング（APIエラー発生時のフロントエンド表示など）。

### フェーズ5: CI/CD とデプロイ

開発したアプリケーションを継続的に統合し、Cloudflare Pages/Workersへデプロイする仕組みを構築します。

1.  **CI/CDパイプライン構築 (GitHub Actions):**
    *   `01_システム概要_PoC.md` の「CI/CD戦略 (PoC)」に基づき、基本的なパイプラインを構築します。
    *   Pull Request時にLint、Format、ビルド、ユニットテストを実行。
    *   `develop` ブランチへのマージ時にプレビュー環境へデプロイ。
    *   `main` ブランチへのマージ時に本番環境へデプロイ (PoCにおける本番)。

2.  **デプロイ設定:**
    *   フロントエンド: Cloudflare Pages
    *   バックエンド: Cloudflare Workers

## 4. 開発における考慮事項

*   **ドキュメントと実装の同期**: `01_システム概要_PoC.md` および `02_ドメインモデル図_PoC.md` と実装の間に乖離が生じないよう、適宜ドキュメントを更新し、開発を進めます。
*   **エラーハンドリングと堅牢性**: `neverthrow` を活用し、エラーが発生しうる箇所ではResult型を返し、堅牢なアプリケーションを目指します。
*   **型安全性**: `zod` によるバリデーションとTypeScriptの型システムを最大限に活用し、型安全性を高めます。ブランデッド型も適宜利用を検討します。
*   **シンプルさの維持**: PoCのスコープを逸脱しないよう、機能追加は慎重に判断し、MVPの実現に集中します。
*   **D1データベース設計**: `02_ドメインモデル図_PoC.md` を参考に、MVPに必要な最小限のテーブル設計から開始し、Drizzle Migrations を用いたスキーマ管理を行います。

## 5. まとめとネクストステップ

上記のフローに基づき、各フェーズのタスクを具体化し、開発に着手します。
まずはフェーズ1の「GTFS静的データの準備と取り込み戦略策定」から開始し、順次バックエンド、フロントエンドの開発へと進めていくことを推奨します。
各フェーズ完了時には、ドキュメントとの整合性を確認することが重要です。 